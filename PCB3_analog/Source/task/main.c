/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "config.h"
#include "platform.h"
#include "LL_API.h"
#include "queue.h"
#include "handlerIOTask.h"
#include "mcp4728.h"


/************************/
/* Select LOOPBACK_MODE */
/************************/

volatile uint32_t u32MiliCount = 0;
volatile uint32_t u32SecCount = 0;

static uint32_t  u32lastprint = 0;



queue_t *DP_RxQueue;
queue_t *DP_TxQueue;

static void SystemClock_Config();
static void setup();


uint8_t tmpval = 0;
int main(void) {
	setup();
	while (1) {
		handler_comdata();
		if((uint32_t)(u32MiliCount - u32lastprint) >= 1000){
			u32lastprint = u32MiliCount;
			if (tmpval) {
				tmpval = 0;
				LED_MCU_ON();
			} else {
				tmpval = 1;
				LED_MCU_OFF();
			}
		}
	}
}

static void setup(){
	SystemClock_Config();
	DP_RxQueue = queue_init(DP_RX_QUEUE_MAX_SIZE);
	DP_TxQueue = queue_init(DP_TX_QUEUE_MAX_SIZE);

	COM_DEBUG_init(115200);
	COM_RS485_init(9600);
	MCP4278_i2c_init();
	pin_init();
	MCP4728_WriteChannel(0, 1024); // Kênh A ~ 50%
	MCP4728_WriteChannel(1, 512); // Kênh B ~ 25%
	MCP4728_WriteChannel(2, 512); // Kênh C ~ 75%
	MCP4728_WriteChannel(3, 512); // Kênh D = Max
	LOG("PCB3 INIT DONE \r\n");
}


static void SystemClock_Config() {

#if 0
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);

	LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
	while (LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
		;
	LL_RCC_HSI_Enable();
	while (LL_RCC_HSI_IsReady() != 1);

	/* Main PLL configuration and activation */
	LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_2, 40,
			LL_RCC_PLLR_DIV_4);
	LL_RCC_PLL_Enable();
	LL_RCC_PLL_EnableDomain_SYS();
	while (LL_RCC_PLL_IsReady() != 1) ;
	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
	}
	/* Set AHB prescaler*/
	LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
	/* Set APB1 prescaler*/
	LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
	SystemCoreClockUpdate();
	SysTick_Config(SystemCoreClock / 1000);
#else
	  LL_RCC_HSI_Enable();
	  while(LL_RCC_HSI_IsReady() != 1);
	  /* Set AHB prescaler*/
	  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
	  /* Sysclk activation on the HSI */
	  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
	  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI);
	  /* Set APB1 prescaler*/
	  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
	  LL_Init1msTick(16000000);
	  /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
	  LL_SetSystemCoreClock(16000000);
	  SysTick_Config(SystemCoreClock / 1000);
#endif
}
